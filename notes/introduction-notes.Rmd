---
title: EHEC, Introduction to R
author:
    name: Alex Hollingsworth, Grant McDermott, and Kelli Marquardt
    affiliation: Indiana University | University of Oregon | Chicago FED
    date: "`r format(Sys.time(), '%d %B %Y')`" ## Or "Lecture no."
output: 
    html_document:
        toc: yes
        toc_depth: 4
        toc_float: yes
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction 

### What is R-Markdown

This is an R-Markdown document. It's a combination of text that is formatted using markdown syntax, R code, and results from running R code. It's saved as an `.Rmd` file. You can also write `.R` code that is analogous to a `.do` file where there's a list of commands with comments. 

- If you are curious about markdown formatting, you can check out this handy guide. https://www.markdownguide.org/basic-syntax/
- To learn more about R-Markdown, this "cheat-sheet" https://www.rstudio.com/wp-content/uploads/2015/02/rmarkdown-cheatsheet.pdf, is a good starting place. 

Basically all of the syntax like italics, headings, bold, citations is added using plain text and is "knit" into a formatted output. It's a bit like Latex in this regard. A nice feature of R-markdown is that you can output in a few different formats: html, pdf, rich text. You can also use a companion `.css` file that contains information on custom formatting preferences, which is especially helpful for html output.

Note: Comments in `.R` files are done with the `#` character. `.Rmd` files are mardown files so the `#` command will create a heading. To make comments in `.Rmd` files you can use html comment syntax `<!––` to start the comment and `––>` to end it. 

This document is about as vanilla as it gets. 

### Send commands to R in R-Markdown 

Behind the scenes, in the `.Rmd` document we are typing in "code-chunks" that get run by R. These code chunks are fenced in with the at the beginning 
and ending with . 

For example, this is a code chunk that will evaluate the command  `sin(3)` 

````
```{r}`r ''`
sin(3)
```
````

The output of this will appear as follows:

```{r echo = FALSE}
sin(3)
```

You can also create calculations inline for example `` `r knitr::inline_expr("sin(3)")` `` will evaluate `sin(3)`. With output rendering like this `r sin(3)`.


## Load packages into memory 

In R, you load packages into your memory. The package must be installed already. Think of it like an application on your phone. Here we are going to load the `ggplot2` package, which is an excellent graphics package. `gg` here stands for "grammar of graphics". This is a part of the `tidyverse` you may have heard of. Later we will cover how to manage packages. 

I will also load the `dplyr` package (also a part of the `tidyverse`) so we can write some cleaner code using "pipes" (the `%>%` syntax). 

```{r load-packages}
library(ggplot2)
library(dplyr)
```

You can install packages using the `install.packages()` syntax, but see the section on `pacman` below before worrying about that. 

## View data

Now that this is loaded into memory, we can begin to use it. Much like stata's auto dataset, many packages have pre-installed datasets that are useful for tutorials and debugging. 

We can look at the first five observations using the `head` command

```{r head-of-data} 
head(diamonds)
```

We can get a list of column names fairly easily too

```{r list-of-column-names}
names(diamonds)
```

Let's compute the average price by color 

```{r mean-price-by-color}
diamonds %>% group_by(color) %>% summarise(mean(price)) 
```

Here the pipe command `%>%` will take the output from the command on the left and "pipes" it as input to the command on the right. So above we 

1. take the dataset called diamonds 
1. send it as input to the command `group_by`, which groups by the unique values in the column `color`
1. We then send this grouped data to the `summarize` command, which calculates the mean price in each group. 

Two things to note. First off, you can just move onto a new line without an error. This is neat because it allows us to write cleaner code and you don't need a delimiter or the `///` you may be used to from stata. So we can rewrite the above like this. 

```{r mean-price-by-color-cleaner}
diamonds %>% 
    group_by(color) %>% 
    summarize(mean(price)) 
```

Second, in more recent versions of R (4.1 and above), you don't need to have `dpylr` installed to pipe. You can do the same thing using `|>`. 

```{r mean-price-by-color-new-pipe}
diamonds |>
    group_by(color) |>
    summarize(mean(price)) 
```

Note: In this example, `%>%` and `|>` are interchangeable, but the two are not interchangeable in all settings. See https://www.r-bloggers.com/2021/05/the-new-r-pipe/ for more details. 

#### Make summary statistics table. 

An annoying, but also powerful, feature of R is that there are 15 ways to accomplish any task. In general limiting the number of packages you use is a good idea since you won't build dependencies on code that could become outdated as base R and other packages are updated. That being said, the power of R is the ability to use fantastic user written packages. Here we will use `modelsummary`'s `datasummary` packages to make fantastic summary statistic plots. Otherwise we'd have to continue to do things like we did above, exploring the data and making summary tables on our own.  


First, load the model summary package 
```{r load-modelsummary}
library(modelsummary)
```


Now we can use the `datasummary_skim` function. 

```{r summary-table}
datasummary_skim(diamonds)
```

But not every variable is numeric. `datasummary` has this covered with the `type = "categorical"` sub-option. 

```{r summary-table-categorical}
datasummary_skim(diamonds, type = "categorical")
```

Learn more about `datasummary` here: https://vincentarelbundock.github.io/modelsummary/articles/datasummary.html 


##  Graphing

Next we will use the `ggplot` function. You can learn more about any R function by typing in `?` before the function name (e.g., `?ggplot`).

- On the first line, we call the function, then clarify  the dataset we wish to use (referable to by its name, `diamonds`), the y-variable (`price`), and the x-variable (`carat`). 
- On the second line, we clarify that we want the geometry to be points

```{r ggplot-1}
ggplot(data = diamonds, aes(y = price, x = carat)) +
    geom_point() 
```

Think changing graphic features in ggplot as adding layers. You can do this by repeating all of the same code. Or by saving the above as an object then adding to that object.

For example let's add a third line where use a default theme called classic that I like. 

```{r ggplot-2}
ggplot(data = diamonds, aes(y = price, x = carat)) +
    geom_point() +
    theme_classic()
```

We can obtain the same result, by saving the above as an object and adding to it. 

```{r ggplot-3}
base_plot = ggplot(data = diamonds, aes(y = price, x = carat)) +
    geom_point()
```

You can also use the `<-` arrow instead of the `=` to the name `base_plot` 

```{r ggplot-4}
base_plot +
    theme_classic()
```

All we need to do is add this theme line `theme_classic()` to the above. 

### Deviations from simple scatter plot

It's very simple to make complex plots in R. 

We can add some transparency 

```{r ggplot-5}
ggplot(data = diamonds, aes(y = price, x = carat)) +
    geom_point(alpha = .33) +
    theme_classic()
```

Customized labels and increased size of text

```{r ggplot-6}
ggplot(data = diamonds, aes(y = price, x = carat)) +
    geom_point(alpha = .1) +
    theme_classic() + 
    theme(text = element_text(size = 18)) +
    labs(title = "Larger diamonds cost more", 
          subtitle = "Price, $",
          y = "", 
          x = "Carat")
```

Recall that the data contain information on diamond color. We can easily create small multiples of the scatter plot for each color. 

```{r ggplot-7}
ggplot(data = diamonds, aes(y = price, x = carat)) +
    geom_point(alpha = .1) +
    facet_wrap(~color) +
    theme_classic() + 
    theme(text = element_text(size = 14)) +
    labs(title = "Larger diamonds cost more by diamond color", 
          subtitle = "Price, $",
          y = "", 
          x = "Carat")
```

Similarly, we can add color (or shapes) based on diamond clarity 

```{r ggplot-8}
ggplot(data = diamonds, aes(y = price, x = carat, color = clarity)) +
    geom_point(alpha = .33) +
    facet_wrap(~color) +
    theme_classic() + 
    theme(text = element_text(size = 14)) +
    labs(title = "Larger diamonds cost more by diamond color", 
          subtitle = "Price, $",
          y = "", 
          x = "Carat")
```

It's also trivial to add a regression line to each. We will pick method `lm`, which is a simple linear regression.

```{r ggplot-9}
ggplot(data = diamonds, aes(y = price, x = carat, color = clarity)) +
    geom_point(alpha = .33) +
    facet_wrap(~color) + 
    geom_smooth(method = "lm") +
    theme_classic() + 
    theme(text = element_text(size = 14)) +
    labs(title = "Larger diamonds cost more by diamond color", 
          subtitle = "Price, $",
          y = "", 
          x = "Carat")
```

We can even remove the points below by simply removing the second line

```{r ggplot-10}
ggplot(data = diamonds, aes(y = price, x = carat, color = clarity)) +
    facet_wrap(~color) + 
    geom_smooth(method = "lm") +
    theme_classic() + 
    theme(text = element_text(size = 14)) +
    labs(title = "Larger diamonds cost more by diamond color", 
          subtitle = "Price, $",
          y = "", 
          x = "Carat")
```

We can use ggplot to create all sorts of cool graphics. See cool gallery with code here: http://r-statistics.co/Top50-Ggplot2-Visualizations-MasterList-R-Code.html

## Run regressions

To do this we can use a few different methods. We will use `modelsummary` and `etable` (from `fixest` package) to display the results

###  Base R

The `lm` function

```{r base-r-regression}
base_model = lm(price ~ carat, data = diamonds)
```


Display the base_model using model summary 

```{r base-r-display}
modelsummary(base_model) 
```

We can tweak this output to look a bit better. We will use the nice `kableExtra` package to help. 

```{r load-kableExtra}
library(kableExtra)
```

```{r base-r-display-with-formatting}
modelsummary(base_model,  
  title = "Fantastic regression table", 
  stars = TRUE,
  gof_omit = "Adj|Pseudo|Log|AIC|BIC|F|R2", 
  coef_omit = c("(Intercept)"), 
  coef_rename = c("carat" = "Carat", 
                  "Num.Obs." = "N")) %>%
  add_footnote("An important note.",
  threeparttable = TRUE)
```

Now we can run all sorts of other models and display them side-by-side. Let's add some controls 

```{r base-r-reg-2}
model_add_controls = lm(price ~ carat + depth + table , data = diamonds)
```

We can add this model to a list with the base model. We name each item here.

```{r base-r-model-save}
models = list(
    "Base"  = base_model, 
    "Add Controls"  = model_add_controls
    )
```

We can use the same format as earlier. 

```{r base-r-model-display-2}
modelsummary(models,  
  title = "Fantastic regression table", 
  stars = TRUE,
  gof_omit = "Adj|Pseudo|Log|AIC|BIC|F|R2", 
  coef_omit = c("(Intercept)"), 
  coef_rename = c("carat" = "Carat", 
                  "Num.Obs." = "N")) %>%
  add_footnote("An important note.",
  threeparttable = TRUE)
```

### Using `fixest`

Next, we will use `fixest` to run a regression with fixed effects. 

```{r load-fixest}
library(fixest)
```

The fixed effects are those after the `|` symbol. 

```{r fixest-model}
fe_model = feols(price ~ carat + depth + table | color + cut + clarity, data = diamonds, cluster = c("color"))
```

Note: Standard errors in `fixest` use a different DoF adjustment than `reghdfe` in stata. To make it comparable, you can set se options following this link: https://cran.r-project.org/web/packages/fixest/vignettes/standard_errors.html


We can create a similar list as earlier. 

```{r fixest-list}
models = list(
    "Base"  = base_model, 
    "Add Controls"  = model_add_controls,
    "Fixed-Effects" = fe_model
)
```

```{r fixest-display}
modelsummary(models,  
  title = "Fantastic regression table", 
  stars = TRUE,
  gof_omit = "Adj|Pseudo|Log|AIC|BIC|F|R2", 
  coef_omit = c("(Intercept)"), 
  coef_rename = c("carat" = "Carat", 
                  "Num.Obs." = "N")) %>%
  add_footnote("An important note.",
  threeparttable = TRUE)
```
See more html display options here, https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html


Now we can export this to latex

```{r fixest-export}
modelsummary(models,  
  title = "Fantastic regression table", 
  stars = TRUE,
  gof_omit = "Adj|Pseudo|Log|AIC|BIC|F|R2", 
  coef_omit = c("(Intercept)"), 
  coef_rename = c("carat" = "Carat", 
                  "Num.Obs." = "N"), 
  output = 'output/table.tex')
```

#### Table using `etable`

We can also use the `etable` function that is a part of `fixest` package. 

```{r fixest-etable-load}
models_for_etable = list(
    "Fixed-Effects" = fe_model
)
```

```{r fixest-etable-display}
etable(models_for_etable) %>%
    kbl(caption = "Fantastic regression table") %>%
    kable_styling(full_width = F)
```

Note: See this excellent blog post by Patrick Baylis on how to "fine-tune" your tables using `etable` for latex export. It's quite simple to do, but will require a bit of time perfecting it to your exact liking. While it's outside the scope of this presentation, it's some hard earned knowledge he's sharing that should make your life easier. https://www.patrickbaylis.com/blog/2021-05-30-making-tables/


## Package management

A key feature of R is that you'll need to have packages installed and load them as needed. This can be painful to keep track of across machines and especially across coauthors. In addition to simply having the package installed, making sure you have the right *version* of the package is important. 

### `pacman`

`pacman` is a fantastically named package manager, it can handle both packages on CRAN and packages stored only on places like github. The `p_load` function will include the library if you have it and install it and include it if you do not. For this code chunk I have it set to not evaluate since we previously included many of these libraries.

At the beginning of your R-script or `.Rmd` file, you can include something like this. 

Make sure you have a place set to download packages from
```{r}
options(repos = c(RSPM = "https://packagemanager.rstudio.com/all/latest"))
```

Then run this code (modfidied for the packages you want)
```{r, eval = FALSE}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(
  ggplot2, dplyr, modelsummary, kableExtra, fixest, devtools
)
pacman::p_load_gh("hemken/Statamarkdown")
```

This will install `pacman` if it's not currently installed. This code also introduces us to some other coding in R. You can call a function from a package using the `::` syntax where the package name is on the left and the function name on the right. This is helpful if there are two packages that have the same function name (e.g., this happens with the `select` function sometimes).

### `renv`

`renv` helps make sure that differences in package versions won't prevent you from being able to replicate your results. Essentially it stores the exact version of each package you are using in a lock file. It makes it easy for another person (or future you) to use the exact same version of each package. It saves these in a `renv.lock` file.  Once you've installed `renv` and you've opened up a new R-project, just type `renv::init()` and you should be good to go. `renv::snapshot()` will update changes. 

You can read more about `renv` here: https://rstudio.github.io/renv/articles/renv.html

## Running stata from R

- First you'll need to make sure that you have stata on the computer you're using. 
- Second, you'll need to install `Statamarkdown`

Here you'd load the package `devtools`, this allows you to install packages from github. If you're using `pacman` the `p_load_gh` function is a great way to load these packages. Then I'll install the `Statamarkdown` package. Again, not needed if you've done this using `pacman` so I've set this code chunk to only show the code and not run it.

```{r load-devtools, eval = FALSE}
library("devtools")
install_github("hemken/Statamarkdown")
```

Load the package `Statamarkdown`, again not needed if using `pacman`.

```{r setup-stata}
library("Statamarkdown")
```

Then you just need to type this code chunk.

````
```{stata}`r ''`
sysuse auto
summarize
```
````

which will result in the following output. 

```{stata, echo = FALSE}
sysuse auto
summarize
pwd
```

It's possible to do this without the `Statamarkdown` package, but I struggeled to get it to work, possibly because I have Stata-MP. You can see this link for more details:  https://bookdown.org/yihui/rmarkdown-cookbook/eng-stata.html For more information on `Statamarkdown` see here: https://www.ssc.wisc.edu/~hemken/Stataworkshops/Stata%20and%20R%20Markdown/StataEnginePath.html



### Meta: Use R to call stata to call R

Say that you have an R-script called `test.R`. This test script just shows `sin(3)` and is saved in the same folder as this `.Rmd` file. 

````
```{stata}`r ''`
shell /usr/local/bin/R --vanilla <test.R
```
````

```{stata, echo = FALSE}
shell /usr/local/bin/R --vanilla <test.R
```

## Misc. tips

### Clear memory

Using  `rm(list = ls())` to clear the objects in memory (not loaded packages). As far as I know you need to restart R to clear out loaded packages, but I'm not 100% sure about this. 
